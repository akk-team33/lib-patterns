package de.team33.patterns.properties.e2;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Map;
import java.util.Optional;
import java.util.TreeMap;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Stream;

import static java.util.Collections.unmodifiableMap;

/**
 * A tool that can be used as an {@link Analyzer}, {@link Synthesizer} and {@link Transmitter}
 * and is generated by reflection from the fields of the underlying type.
 * <p>
 * Use {@link #of(Class, Mode)} to get a new instance.
 *
 * @param <T> The underlying type.
 */
public final class Fields<T> implements Analyzer<T>, Synthesizer<T>, Transmitter<T> {

    private static final int SYNTHETIC = 0x00001000;
    private static final int NOT_SIGNIFICANT = Modifier.STATIC | Modifier.TRANSIENT | SYNTHETIC;
    private static final String CANNOT_GET_VALUE = //
            "The value of an alleged field of the given target instance cannot be determined:%n" +
                    "- field: %s%n" +
                    "- type of the target instance: %s%n" +
                    "- the target instance: %s%n";
    private static final String CANNOT_SET_VALUE = //
            "An alleged field of the given target instance cannot be set to the given value:%n" +
                    "- field: %s%n" +
                    "- value: %s%n" +
                    "- type of the target instance: %s%n" +
                    "- the target instance: %s%n";

    private final Map<String, Field> fieldMap;

    private Fields(final Class<T> tClass, final Stream<Field> stream) {
        this.fieldMap = unmodifiableMap(stream.collect(TreeMap::new, addition(tClass), Map::putAll));
    }

    private static BiConsumer<Map<String, Field>, Field> addition(final Class<?> context) {
        return (map, field) -> map.put(nameOf(field, context), field);
    }

    private static String nameOf(final Field field, final Class<?> context) {
        return context.equals(field.getDeclaringClass())
                ? field.getName()
                : "." + nameOf(field, context.getSuperclass());
    }

    /**
     * Produces a new instance that considers certain fields of a given class as properties.
     *
     * @param tClass The {@link Class} whose fields are to be considered as properties.
     * @param mode   The {@link Mode} that determines which fields of the class should be considered as properties.
     * @return The new instance.
     */
    public static <T> Fields<T> of(final Class<T> tClass, final Mode mode) {
        return new Fields<>(tClass, mode.streaming.apply(tClass));
    }

    private static Stream<Field> streamDeclared(final Class<?> type) {
        return Stream.of(type.getDeclaredFields());
    }

    private static Stream<Field> streamDeclaredDeep(final Class<?> type) {
        return Stream.concat(superStreamOf(type), streamDeclared(type));
    }

    private static Stream<Field> superStreamOf(final Class<?> cls) {
        return Optional.ofNullable(cls.getSuperclass())
                       .map(Fields::streamDeclaredDeep)
                       .orElseGet(Stream::empty);
    }

    private static boolean isSignificant(final Field field) {
        return isSignificant(field.getModifiers());
    }

    private static boolean isSignificant(final int modifiers) {
        return 0 == (modifiers & NOT_SIGNIFICANT);
    }

    private static void setAccessible(final Field field) {
        field.setAccessible(true);
    }

    private static Object valueOf(final Field field, final Object subject) {
        try {
            return field.get(subject);
        } catch (final IllegalArgumentException | IllegalAccessException e) {
            throw new IllegalArgumentException(
                    String.format(CANNOT_GET_VALUE, field, subject.getClass(), subject), e);
        }
    }

    private static void setValueOf(final Field field, final Object subject, final Object value) {
        try {
            field.set(subject, value);
        } catch (final IllegalArgumentException | IllegalAccessException e) {
            throw new IllegalArgumentException(
                    String.format(CANNOT_SET_VALUE, field, value, subject.getClass(), subject), e);
        }
    }

    @Override
    public final <M extends Map<String, Object>> M analyse(final T origin, final M target) {
        fieldMap.forEach((name, field) -> target.put(name, valueOf(field, origin)));
        return target;
    }

    @Override
    public final T synthesize(final Map<?, ?> origin, final T target) {
        fieldMap.forEach((name, field) -> setValueOf(field, target, origin.get(name)));
        return target;
    }

    @Override
    public final T transmit(final T origin, final T target) {
        fieldMap.values().forEach(field -> setValueOf(field, target, valueOf(field, origin)));
        return target;
    }

    /**
     * Defines modes for determining relevant fields of a class that represent its properties.
     */
    public enum Mode {

        /**
         * In this mode, all fields are taken into account that were defined directly with the relevant class
         * and that are not static, transient or synthetic.
         */
        STRAIGHT(type -> streamDeclared(type).filter(Fields::isSignificant)
                                             .peek(Fields::setAccessible)),

        /**
         * In this mode, all fields are taken into account that were defined with the relevant class or one of its
         * superclasses and that are not static, transient or synthetic.
         */
        DEEP(type -> streamDeclaredDeep(type).filter(Fields::isSignificant)
                                             .peek(Fields::setAccessible));

        private final Function<Class<?>, Stream<Field>> streaming;

        Mode(final Function<Class<?>, Stream<Field>> streaming) {
            this.streaming = streaming;
        }
    }
}
